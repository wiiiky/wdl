/*
 * Copyright (C) 2014-2014 Wiky L(wiiiky@yeah.net)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * this file is generated by gobj(https://github.com/wiiiky/gobj)
 */

#include "wlbtfilechooser.h"
#include <string.h>

enum {
	WL_BT_FILE_CHOOSER_PROPERTY_TORRENT = 1,
	WL_BT_FILE_CHOOSER_PROPERTY_CTOR,
	WL_BT_FILE_CHOOSER_PROPERTY_PATH,
};


/* UI各部分的名字 */
#define UI_WINDOW	"torrent_window"
#define UI_TORRENT   "torrent_chooser"
#define UI_FOLDER   "folder_chooser"
#define UI_TREEVIEW "file_view"
#define UI_SPACE	"space_label"
#define UI_TREESTORE	"file_tree"
#define UI_OPEN "open_button"
#define UI_CANCEL   "cancel_button"

/* 常用图标的名字 */
#define ICON_FOLDER "folder"


#define TREEVIEW_ICON_SIZE  16

#define TREE_STORE_COL_ICON (0)
#define TREE_STORE_COL_NAME (1)
#define TREE_STORE_COL_SIZE (2)
#define TREE_STORE_COL_DL   (3)
#define TREE_STORE_COL_INDEX	(4)

G_DEFINE_TYPE(WlBtFileChooser, wl_bt_file_chooser, GTK_TYPE_BUILDER);

static void wl_bt_file_chooser_init(WlBtFileChooser * obj);
static void wl_bt_file_chooser_finalize(GObject * obj);
static void wl_bt_file_chooser_class_init(WlBtFileChooserClass * klass);
static void wl_bt_file_chooser_getter(GObject * object, guint property_id,
									  GValue * value, GParamSpec * ps);
static void wl_bt_file_chooser_setter(GObject * object, guint property_id,
									  const GValue * value,
									  GParamSpec * ps);
static inline void wl_bt_file_chooser_update(WlBtFileChooser * chooser);
static gboolean wl_bt_file_chooser_close(GtkWidget * widget,
										 GdkEvent * event, gpointer data);
static void wl_bt_file_chooser_open(GtkWidget * button, gpointer data);
static void wl_bt_file_chooser_cancel(GtkWidget * button, gpointer data);

/* 将字节大小转化为可读的字符串形式 */
static const gchar *make_size_readable(guint64 size);

/* 将图标转化为GdkPixbuf形式 */
static GdkPixbuf *get_pixbuf_from_icon(GtkIconTheme * icon_theme,
									   GThemedIcon * icon, gint size);
static GdkPixbuf *get_pixbuf_from_icon_name(const gchar * name, gint size);

static void wl_bt_file_chooser_init(WlBtFileChooser * chooser)
{
	if (!gtk_builder_add_from_file(GTK_BUILDER(chooser), UI_FILE, NULL)) {
		/* 载入失败退出程序 */
		g_error("Fail to load " UI_FILE);
	}

	chooser->window =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_WINDOW);

	chooser->default_path =
		g_strdup(g_get_user_special_dir(G_USER_DIRECTORY_DOWNLOAD));
	chooser->torrent = NULL;
	chooser->ctor = NULL;
	chooser->loop = NULL;
}

static void wl_bt_file_chooser_finalize(GObject * obj)
{
	WlBtFileChooser *chooser = WL_BT_FILE_CHOOSER(obj);
	g_free(chooser->default_path);
}

static void wl_bt_file_chooser_class_init(WlBtFileChooserClass * klass)
{
	GObjectClass *obj_class = G_OBJECT_CLASS(klass);
	obj_class->get_property = wl_bt_file_chooser_getter;
	obj_class->set_property = wl_bt_file_chooser_setter;
	obj_class->finalize = wl_bt_file_chooser_finalize;

	GParamSpec *ps;
	/* properties */
	ps = g_param_spec_pointer("torrent",
							  "BT torrent",
							  "BT Torrent",
							  G_PARAM_READABLE | G_PARAM_WRITABLE);
	g_object_class_install_property(obj_class,
									WL_BT_FILE_CHOOSER_PROPERTY_TORRENT,
									ps);

	ps = g_param_spec_pointer("ctor",
							  "torrent constructor",
							  "Torrent Constructor",
							  G_PARAM_READABLE | G_PARAM_WRITABLE);
	g_object_class_install_property(obj_class,
									WL_BT_FILE_CHOOSER_PROPERTY_CTOR, ps);

	ps = g_param_spec_string("path",
							 "default download path",
							 "Default Download Path",
							 NULL, G_PARAM_READABLE | G_PARAM_WRITABLE);
	g_object_class_install_property(obj_class,
									WL_BT_FILE_CHOOSER_PROPERTY_PATH, ps);
}

static void wl_bt_file_chooser_getter(GObject * object, guint property_id,
									  GValue * value, GParamSpec * ps)
{
	WlBtFileChooser *obj = WL_BT_FILE_CHOOSER(object);
	switch (property_id) {
	case WL_BT_FILE_CHOOSER_PROPERTY_TORRENT:
		g_value_set_pointer(value, obj->torrent);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_CTOR:
		g_value_set_pointer(value, obj->ctor);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_PATH:
		g_value_set_string(value, obj->default_path);
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static void wl_bt_file_chooser_setter(GObject * object, guint property_id,
									  const GValue * value,
									  GParamSpec * ps)
{
	WlBtFileChooser *obj = WL_BT_FILE_CHOOSER(object);
	switch (property_id) {
	case WL_BT_FILE_CHOOSER_PROPERTY_TORRENT:
		obj->torrent = g_value_get_pointer(value);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_CTOR:
		obj->ctor = g_value_get_pointer(value);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_PATH:
		if (!g_file_test(g_value_get_string(value), G_FILE_TEST_IS_DIR))	/* 目录不存在则不设置 */
			break;
		g_free(obj->default_path);
		obj->default_path = g_strdup(g_value_get_string(value));
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static GdkPixbuf *get_pixbuf_from_icon(GtkIconTheme * icon_theme,
									   GThemedIcon * icon, gint size)
{
	char **icon_names;
	GtkIconInfo *icon_info;
	GdkPixbuf *pixbuf;
	GError *error = NULL;

	g_object_get(icon, "names", &icon_names, NULL);

	icon_info =
		gtk_icon_theme_choose_icon(icon_theme, (const char **) icon_names,
								   size, 0);
	if (icon_info == NULL)
		return NULL;
	pixbuf = gtk_icon_info_load_icon(icon_info, &error);

	g_object_unref(icon_info);
	g_strfreev(icon_names);

	return pixbuf;
}

static GdkPixbuf *get_pixbuf_from_icon_name(const gchar * name, gint size)
{
	static GtkIconTheme *theme = NULL;
	GIcon *icon = g_themed_icon_new(name);
	if (icon == NULL)
		return NULL;
	if (theme == NULL) {
		theme = gtk_icon_theme_get_default();
	}
	GdkPixbuf *pixbuf =
		get_pixbuf_from_icon(theme, G_THEMED_ICON(icon), size);
	g_object_unref(icon);
	return pixbuf;
}

static gboolean wl_bt_file_chooser_close(GtkWidget * widget,
										 GdkEvent * event, gpointer data)
{
	gtk_widget_hide(widget);
	GMainLoop *loop = data;
	if (g_main_loop_is_running(loop))
		g_main_loop_quit(loop);
	return TRUE;
}

static void wl_bt_file_chooser_open(GtkWidget * button, gpointer data)
{
	WlBtFileChooser *chooser = data;
	GMainLoop *loop = chooser->loop;
	gtk_widget_hide(GTK_WIDGET(chooser->window));
	if (g_main_loop_is_running(loop))
		g_main_loop_quit(loop);
}

static void wl_bt_file_chooser_cancel(GtkWidget * button, gpointer data)
{
	WlBtFileChooser *chooser = data;
	GMainLoop *loop = chooser->loop;
	gtk_widget_hide(GTK_WIDGET(chooser->window));
	if (chooser->torrent)
		tr_torrentRemove(chooser->torrent, FALSE, 0);
	chooser->torrent = NULL;
	if (g_main_loop_is_running(loop))
		g_main_loop_quit(loop);
}

/* 将字节大小转化为可读的字符串形式 */
static const gchar *make_size_readable(guint64 size)
{
	static gchar string[20];
	if (size >= 1000 * 1000 * 1000) {	/* GB */
		g_snprintf(string, 20, "%.1f GB",
				   (gdouble) size / (1000.0 * 1000.0 * 1000.0));
	} else if (size >= 1000 * 1000) {
		g_snprintf(string, 20, "%.1f MB",
				   (gdouble) size / (1000.0 * 1000.0));
	} else if (size >= 1000) {
		g_snprintf(string, 20, "%.1f KB", (gdouble) size / (1000.0));
	} else {
		g_snprintf(string, 20, "%lu B", size);
	}
	return string;
}

#include "icons.h"

static inline void wl_bt_file_chooser_update(WlBtFileChooser * chooser)
{
	tr_ctor *ctor = chooser->ctor;
	tr_torrent *torrent = tr_torrentNew(ctor, NULL, NULL);
	chooser->torrent = torrent;
	if (torrent == NULL)
		return;
	GtkBuilder *ui = GTK_BUILDER(chooser);
	GtkFileChooserButton *fc_button =
		(GtkFileChooserButton *) gtk_builder_get_object(ui,
														UI_TORRENT);
	GtkFileChooserButton *dc_button =
		(GtkFileChooserButton *) gtk_builder_get_object(ui,
														UI_FOLDER);
	GtkLabel *space_label =
		(GtkLabel *) gtk_builder_get_object(ui, UI_SPACE);

	/* 种子文件和保存路径 */
	gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(fc_button),
								  tr_ctorGetSourceFile(ctor));
	gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dc_button),
								  chooser->default_path);

	/* 磁盘空余 */
	GFile *file = g_file_new_for_path(tr_ctorGetSourceFile(ctor));
	GFileInfo *info = g_file_query_filesystem_info(file,
												   G_FILE_ATTRIBUTE_FILESYSTEM_FREE,
												   NULL, NULL);
	guint64 free_space = g_file_info_get_attribute_uint64(info,
														  G_FILE_ATTRIBUTE_FILESYSTEM_FREE);
	gtk_label_set_text(space_label, make_size_readable(free_space));
	g_object_unref(info);
	g_object_unref(file);

	/* 文件s */
	GtkTreeStore *file_tree =
		(GtkTreeStore *) gtk_builder_get_object(ui, UI_TREESTORE);
	GtkTreeView *tree_view =
		(GtkTreeView *) gtk_builder_get_object(ui, UI_TREEVIEW);
	gtk_tree_store_clear(file_tree);
	const tr_info *torrent_info = tr_torrentInfo(torrent);
	/* 根目录 */
	GtkTreeIter root_iter;
	gtk_tree_store_append(file_tree, &root_iter, NULL);
	gtk_tree_store_set(file_tree, &root_iter,
					   TREE_STORE_COL_ICON,
					   get_pixbuf_from_icon_name(ICON_FOLDER,
												 TREEVIEW_ICON_SIZE),
					   TREE_STORE_COL_NAME, torrent_info->originalName,
					   TREE_STORE_COL_SIZE,
					   make_size_readable(torrent_info->totalSize),
					   TREE_STORE_COL_DL, TRUE, -1);
	gint i;
	/* TODO show files in a tree view */
	for (i = 0; i < torrent_info->fileCount; i++) {
		const tr_file *torrent_file = &torrent_info->files[i];
		gchar **paths = g_strsplit(torrent_file->name, "/", -1);
		GtkTreeIter iter;
		memcpy(&iter, &root_iter, sizeof(GtkTreeIter));
		gint j;
		/* 扫描目录 */
		for (j = 0; paths[j + 1] != NULL; j++) {
			gchar *name = NULL;
			gtk_tree_model_get(GTK_TREE_MODEL(file_tree), &iter,
							   TREE_STORE_COL_NAME, &name, -1);
			g_message("%s\n%s", name, paths[j]);
			if (g_strcmp0(name, paths[j]) == 0) {
				/* 当前路径已经存在，查找或者创建子路径 */
				gint n =
					gtk_tree_model_iter_n_children(GTK_TREE_MODEL
												   (file_tree), &iter);
				gint k;
				for (k = 0; k < n; k++) {
					GtkTreeIter child_iter;
					gtk_tree_model_iter_nth_child(GTK_TREE_MODEL
												  (file_tree), &child_iter,
												  &iter, k);
					gchar *child_name = NULL;
					gtk_tree_model_get(GTK_TREE_MODEL(file_tree),
									   &child_iter, TREE_STORE_COL_NAME,
									   &child_name, -1);
					if (g_strcmp0(child_name, paths[j + 1]) == 0) {
						memcpy(&iter, &child_iter, sizeof(GtkTreeIter));
						g_free(child_name);
						break;
					}
					g_free(child_name);
				}
				if (k == n) {	/* 未找到子路径 */
					gtk_tree_store_append(file_tree, &iter, &iter);
					gtk_tree_store_set(file_tree, &iter,
									   TREE_STORE_COL_ICON,
									   get_pixbuf_from_icon_name
									   (ICON_FOLDER, TREEVIEW_ICON_SIZE),
									   TREE_STORE_COL_NAME, paths[j + 1],
									   TREE_STORE_COL_DL, TRUE, -1);
				}
			} else {
				g_error("%s\n%s", name, paths[j]);
			}
			g_free(name);
		}
		gtk_tree_store_set(file_tree, &iter,
						   TREE_STORE_COL_ICON,
						   wdl_get_pixbuf_from_filename(paths[j],
														GTK_ICON_SIZE_MENU),
						   TREE_STORE_COL_NAME, paths[j],
						   TREE_STORE_COL_SIZE,
						   make_size_readable(torrent_file->length),
						   TREE_STORE_COL_DL, TRUE, -1);
		//g_message("%s", torrent_file->name);
		g_strfreev(paths);
	}

	/* expand all */
	gtk_tree_view_expand_all(tree_view);
}

static inline void wl_bt_file_chooser_show_invalid(GtkWidget * window)
{
	GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window),
											   GTK_DIALOG_MODAL |
											   GTK_DIALOG_DESTROY_WITH_PARENT,
											   GTK_MESSAGE_ERROR,
											   GTK_BUTTONS_OK,
											   "Invalid Torrent File!");
	gtk_dialog_run(GTK_DIALOG(dialog));
	gtk_widget_destroy(dialog);
}


/**********************************************************
 * PUBLIC
 **********************************************************/
WlBtFileChooser *wl_bt_file_chooser_new(tr_ctor * ctor)
{
	WlBtFileChooser *chooser =
		(WlBtFileChooser *) g_object_new(WL_TYPE_BT_FILE_CHOOSER, "ctor",
										 ctor, NULL);

	return chooser;
}

void wl_bt_file_chooser_set_download_path(WlBtFileChooser * chooser,
										  const gchar * path)
{
	g_return_if_fail(WL_IS_BT_FILE_CHOOSER(chooser));
	g_object_set(G_OBJECT(chooser), "path", path, NULL);
}

tr_torrent *wl_bt_file_chooser_run(WlBtFileChooser * chooser,
								   const gchar * path)
{
	g_return_val_if_fail(WL_IS_BT_FILE_CHOOSER(chooser)
						 && path != NULL, FALSE);
	GtkWidget *window = chooser->window;
	GtkWidget *open_button =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_OPEN);
	GtkWidget *cancel_button =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_CANCEL);

	if (tr_ctorSetMetainfoFromFile(chooser->ctor, path)) {	/* 无效的文件 */
		wl_bt_file_chooser_show_invalid(window);
		return NULL;
	}
	wl_bt_file_chooser_update(chooser);

	gtk_widget_show_all(window);

	GMainLoop *loop = g_main_loop_new(NULL, FALSE);
	chooser->loop = loop;
	gulong delete_handler =
		g_signal_connect(G_OBJECT(window), "delete-event",
						 G_CALLBACK(wl_bt_file_chooser_close), loop);
	gulong open_handler =
		g_signal_connect(G_OBJECT(open_button), "clicked",
						 G_CALLBACK(wl_bt_file_chooser_open), chooser);
	gulong cancel_handler =
		g_signal_connect(G_OBJECT(cancel_button), "clicked",
						 G_CALLBACK(wl_bt_file_chooser_cancel), chooser);

	g_main_loop_run(loop);
	g_main_loop_unref(loop);
	/* disconnect */
	g_signal_handler_disconnect(window, delete_handler);
	g_signal_handler_disconnect(open_button, open_handler);

	return chooser->torrent;
}
